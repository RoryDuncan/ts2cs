import { Project, SourceFile, ClassDeclaration } from 'ts-morph';

/**
 * The auto-generated header comment added to all C# files
 */
export const GENERATED_HEADER = `// <auto-generated>
//     This file was generated by ts2cs-transpiler. Do not edit manually.
// </auto-generated>`;

/**
 * Known Godot base classes that trigger `using Godot;`
 */
const GODOT_CLASSES = new Set([
  // Core nodes
  'Node', 'Node2D', 'Node3D',
  // Sprites
  'Sprite2D', 'Sprite3D',
  // Physics bodies
  'CharacterBody2D', 'CharacterBody3D',
  'RigidBody2D', 'RigidBody3D',
  'StaticBody2D', 'StaticBody3D',
  // Areas
  'Area2D', 'Area3D',
  // UI
  'Control', 'Label', 'Button', 'TextEdit', 'LineEdit',
  'Panel', 'Container', 'BoxContainer', 'VBoxContainer', 'HBoxContainer',
  // Resources
  'Resource', 'RefCounted',
  // Other common types
  'Camera2D', 'Camera3D',
  'AudioStreamPlayer', 'AudioStreamPlayer2D', 'AudioStreamPlayer3D',
  'AnimationPlayer', 'AnimatedSprite2D', 'AnimatedSprite3D',
  'TileMap', 'TileMapLayer',
  'CanvasLayer',
  'Viewport',
  'Timer',
]);

/**
 * Check if a class name is a known Godot class
 */
export function isGodotClass(className: string): boolean {
  return GODOT_CLASSES.has(className);
}

/**
 * Transpile a single TypeScript source string to C#
 */
export function transpileSource(tsSource: string, fileName: string = 'source.ts'): string {
  const project = new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      target: 99, // ESNext
      module: 99, // ESNext
      strict: true,
    },
  });

  const sourceFile = project.createSourceFile(fileName, tsSource);
  return transpileSourceFile(sourceFile);
}

/**
 * Transpile a ts-morph SourceFile to C#
 */
export function transpileSourceFile(sourceFile: SourceFile): string {
  const classes = sourceFile.getClasses();
  
  if (classes.length === 0) {
    // Empty file or no classes - just return header
    return GENERATED_HEADER;
  }

  const parts: string[] = [GENERATED_HEADER, ''];

  // Check if any class extends a Godot type
  const needsGodotUsing = classes.some(cls => {
    const baseClass = cls.getExtends();
    if (!baseClass) return false;
    const baseName = baseClass.getExpression().getText();
    return isGodotClass(baseName);
  });

  if (needsGodotUsing) {
    parts.push('using Godot;');
    parts.push('');
  }

  // Transpile each class
  for (const cls of classes) {
    parts.push(transpileClass(cls));
    parts.push('');
  }

  // Remove trailing empty line and join
  while (parts.length > 0 && parts[parts.length - 1] === '') {
    parts.pop();
  }

  return parts.join('\n');
}

/**
 * Transpile a single class declaration to C#
 */
function transpileClass(cls: ClassDeclaration): string {
  const className = cls.getName() ?? 'UnnamedClass';
  const baseClass = cls.getExtends();
  
  let declaration = `public partial class ${className}`;
  
  if (baseClass) {
    const baseName = baseClass.getExpression().getText();
    declaration += ` : ${baseName}`;
  }

  // For now, emit empty class body
  return `${declaration}\n{\n}`;
}

