import { Project, SourceFile, ClassDeclaration } from 'ts-morph';
import { isGodotClass } from './godot/index.js';
import { TranspilerConfig, getTypeMappings, ResolvedTypeMappings, parseConfig } from './config/schema.js';
import { transpileClassProperties } from './transformers/properties.js';
import { transpileClassMethods, transpileClassConstructors } from './transformers/methods.js';

/**
 * The auto-generated header comment added to all C# files
 */
export const GENERATED_HEADER = `// <auto-generated>
//     This file was generated by ts2cs-transpiler. Do not edit manually.
// </auto-generated>`;

/**
 * Default config for single-source transpilation
 */
const DEFAULT_CONFIG: TranspilerConfig = parseConfig({
  inputDir: './src',
  outputDir: './out',
});

/**
 * Transpile context passed through the transpilation pipeline
 */
export interface TranspileContext {
  config: TranspilerConfig;
  mappings: ResolvedTypeMappings;
}

/**
 * Create a transpile context from config
 */
export function createContext(config?: Partial<TranspilerConfig>): TranspileContext {
  const fullConfig = config 
    ? parseConfig({ ...DEFAULT_CONFIG, ...config })
    : DEFAULT_CONFIG;
  
  return {
    config: fullConfig,
    mappings: getTypeMappings(fullConfig),
  };
}

/**
 * Transpile a single TypeScript source string to C#
 */
export function transpileSource(
  tsSource: string, 
  fileName: string = 'source.ts',
  config?: Partial<TranspilerConfig>
): string {
  const project = new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      target: 99, // ESNext
      module: 99, // ESNext
      strict: true,
    },
  });

  const sourceFile = project.createSourceFile(fileName, tsSource);
  const context = createContext(config);
  return transpileSourceFile(sourceFile, context);
}

/**
 * Transpile a ts-morph SourceFile to C#
 */
export function transpileSourceFile(sourceFile: SourceFile, context: TranspileContext): string {
  const classes = sourceFile.getClasses();
  
  if (classes.length === 0) {
    // Empty file or no classes - just return header
    return GENERATED_HEADER;
  }

  const parts: string[] = [GENERATED_HEADER, ''];

  // Check if any class extends a Godot type
  const needsGodotUsing = classes.some(cls => {
    const baseClass = cls.getExtends();
    if (!baseClass) return false;
    const baseName = baseClass.getExpression().getText();
    return isGodotClass(baseName);
  });

  if (needsGodotUsing) {
    parts.push('using Godot;');
    parts.push('');
  }

  // Transpile each class
  for (const cls of classes) {
    parts.push(transpileClass(cls, context));
    parts.push('');
  }

  // Remove trailing empty line and join
  while (parts.length > 0 && parts[parts.length - 1] === '') {
    parts.pop();
  }

  return parts.join('\n');
}

/**
 * Transpile a single class declaration to C#
 */
function transpileClass(cls: ClassDeclaration, context: TranspileContext): string {
  const className = cls.getName() ?? 'UnnamedClass';
  const baseClass = cls.getExtends();
  const isAbstract = cls.isAbstract();
  
  // Build class declaration
  let declaration = 'public ';
  if (isAbstract) {
    declaration += 'abstract ';
  }
  declaration += `partial class ${className}`;
  
  if (baseClass) {
    const baseName = baseClass.getExpression().getText();
    declaration += ` : ${baseName}`;
  }

  // Get class body parts
  const bodyParts: string[] = [];

  // Transpile properties
  const properties = transpileClassProperties(cls, context.mappings);
  bodyParts.push(...properties);

  // Transpile constructors
  const constructors = transpileClassConstructors(cls, context.mappings);
  bodyParts.push(...constructors);

  // Transpile methods
  const methods = transpileClassMethods(cls, context.mappings);
  bodyParts.push(...methods);

  // TODO: Transpile getters/setters

  // Build class body
  if (bodyParts.length === 0) {
    return `${declaration}\n{\n}`;
  }

  const body = bodyParts.join('\n');
  return `${declaration}\n{\n${body}\n}`;
}
